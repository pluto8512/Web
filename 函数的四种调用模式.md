 #函数的四种调用模式(非常非常重要)
1. 调用模式

> 函数模式
> 方法模式
> 构造器模式
> 上下文模式

2. 函数的定义方式

> 声明式
> 表达式式
> Function

```javascript
// 1. 函数模式
function foo () {
   console.log("1");
}
foo();
//this 表示全局对象
//任何自调用都是函数调用模式

// 2. 方法调用模式
// -> 区分
// 方法本生就是函数,但是是通过对象引导调用
// 对象.方法( 参数 )
// this 表示 引导放的对象
function foo () {
   console.log(this);
}
var o = {name:"jack"];
o.foo = foo;

foo();
o.foo();

function func () {
   console.log("2"); 
}
func.foo = foo;
func.foo(); //打印函数体

var arr = [1,2,3];
arr.foo = foo; 
arr.foo(); //打印数组对象

var arr = [1,2,3,function(){
   console.log(this);
}] ;
arr[3]();// 打印数组

// 3. 构造器模式(或者叫做构造函数模式,构造方法模式)
// 构造器的执行步骤
var p = new Person ();
// new 是一个运算符,专门用来申请创建对象
// 创建出来的对象传递给构造函数的this,利用构造函数来进行初始化
// 构造函数不写return默认返回this.

//构造函数的return语句

```
```javascript
//面试题
function Foo(){
   getName = function(){alert(1);}
   return this;
} 
Foo.getName = function(){ alert(2);};
Foo.prototype.getName =  function() {alert(3);};
var getName = function() {alert(4);}
function getName() {alert(5);}

Foo.getName();
getName();
Foo().getName;
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

//分析
//预解析得到
function Foo(){
   getName = function(){alert(1);}
   return this;
} 
//预解析得到
function getName() {alert(5);}

Foo.getName = function(){ alert(2);};
Foo.prototype.getName =  function() {alert(3);};//实例才会访问到

//覆盖前面的getName
//new 的优先级小于圆点的优先级
getName = function() {alert(4);}

Foo.getName();//2
getName();//4
Foo().getName;//首先函数调用模式,返回this即window
              //同时给getName重新赋值
              //打印1
getName();//1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//new (new Foo()).getName() //3
```