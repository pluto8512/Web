#正则regular expression 一个有规则的表达式

简单描述: 一个用于查找的统配符

正则表达式对象

js 正则表达式对象 由正则表达式创建出来的对象, 可以进行 匹配,提取和替换

1. 创建正则表达式对象

   构造函数 

   var regex = new RegExp("123");

2. 字面量
   
   var regex = /abc/;
   
使用正则表达式进行匹配

语法: 

   正则对象.test( 字符串) -> 返回bool值

如果参数字符串中含有 复合 

```javascript
var str = "qwertyuitcastopp";
var r1 = new RegExp("itcast");
var r2 = /itcast/;

var res = r2.test( str );

console.log( res );//true 
```
> slice(1,2)//从第一个截取到第三个,不含第三个
strsubstr(1,2)//从第一截取到第三个,含第三个

基本元字符

-  `.`  : 表示一个非换行字符
- `()` : 分组提高优先级
- `[]` : 表示一个出现在[]中的字符
- `|`  : 或

转义字符

- `\(abc\)` :表示圆括号

限定元字符

- `*` 紧跟前面的一个字符或一组字符出现 `0` 次到`多次` : 
- `+` 紧跟前面的一个字符出现 `1` 次到`多次` : 
- `?` 紧跟前面的一个字符出现 `0` 次到`1`次  :
- `{数字}` 紧跟前面的一个字符出现指定次数
- `{数字,}` 紧跟前面的一个字符`至少`出现指定次数
- `{数字,数字}` 紧跟前面的一个字符出现次数的`范围`

首尾元字符

- `^`: 必须以 `xxx` 开头
- `$`: 必须以 `xxx` 结尾

```javascript
//demo1/////////////////////////////
var reg = /^a+$/;
console.log(reg.test('aaaaaaaaaaa'));
//END///////////////////////////////

//demo2/////////////////////////////
//匹配身份证 18位 数字 省 市 区 出生年月 随机编码x
^[0123456789]{18}$ -->
^[0123456789]{17}[0123456789x]$
//END///////////////////////////////

//demo3/////////////////////////////
// 匹配邮箱 
  /^[0-9a-zA-Z]+@[0-9a-zA-Z]+(\.[0-9a-zA-Z]+)+$/
//END///////////////////////////////

//demo4/////////////////////////////
// 匹配一个数字
// [0-9]+
// 1) 由于是匹配, 包含 ^ $
// 2) 首先第一个字符不允许是 0, 所以第一个可以写成 [1-9]
// 3) 后面的数字就是 [0-9]
// 4) 要求后面的数字出现 0 次到多次, 以匹配任意的 非 0 数字: [1-9][0-9]*
// 5) 由于还需要考虑 0, 因此写成 [1-9][0-9]*|0
// 6) 考虑 | 优先级最低: ^([1-9][0-9]*|0)$
^(-?[1-9][0-9]*|0)$
//END/////////////////////////////// 

//demo5/////////////////////////////
// 匹配一个指定范围的数字 以0~255为例
// 需要将字符串结构进行分类
// 1) 0 要匹配的, 所以在正则表达式中有 0 这一项
// 2) 任意的 2 位数, 即 [1-9][0-9]
// 3) 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并
// 4) 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制
// 因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9]
// 5) 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以写成: 2[0-4][0-9]
// 6) 考虑 250 到 255, 写成 25[0-5]
^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$

匹配 IPv4 
127.0.0.1
192.168.1.1
^(()\.()\.()\.())$
^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))$
//END///////////////////////////////

//demo6///////////////////////////// 
//匹配小数或整数

^((-?[1-9][0-9]*|0)(\.[0-9]*[1-9])?)$

// (aaa)? 这个内容出现或不出现
// (aaa|) 也是表达式aaa可出现可不出现
//END///////////////////////////////
```

简写元字符

- \s 空白字符, 包括空格, tab, 回车换行等
- \S 非空白字符 
- js 中常常使用 [\s\S] 表示任意字符
- \w 表示字符, 包含字母, 数字, 下划线. 
- \W 非字符
- \d 数字
- \D 非数字

###提取

使用正则表达式可以进行匹配,使用exec 可以将匹配到的数据提取出来

语法: 
 
正则表达式.exec(字符串) -> 封装成数组

```javascript
//demo1//////////////////
//提取数字
var str = 'werthjkmn5454bvzxc135423v';
var r= /\d+/;
var result = r.exec(str);
console.log(result);
//END////////////////////

//demo2//////////////////
//循环提取字符串中复合震泽表达式的内容
//正则表达式需要设置全局模式
//var r = new RegExp("正则","g");
//var r = /正则/g; 

var str = 'werthjkmn5454bvzxc135423v';
var r = /\d+/g;

var res;
//r.exec(str)匹配不到的时候会返回null
while (res = r.exec(str)) {
   //操作res,处理捕获的结果
   console.log(res);  //循环打印
}
//END////////////////////

//demo2//////////////////
//假如有一个字符串: itcast@itcast.cn
//匹配提取邮箱, 同时将邮箱地址部分的名字和主机名都提取出来
//案例:
//var str = '我有一个邮箱, 是 itcast@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com'
//要求将里面的邮箱全部提取出来, 然后将名字还有主机名也取出来

//循环提取
var r = /[a-zA-Z\d]+@[a-zA-Z\d]+(\.[a-zA-Z\d])+/g;
// 如果需要将匹配到的结果再次分解, 可以使用分组的形式, 在正则中分组即可
var r = /([a-zA-Z\d]+)@([a-zA-Z\d]+(\.[a-zA-Z\d]+)+)/g;
// 注意, 正则表达式中, 分组是有编号的. 从左往右数 '('. 从 1 开始依次编号
// 匹配提取的结果中, 对应的编号就可以获得分解的数据
//END////////////////////

//demo2//////////////////
//分组提取
var str = "2000年12月9日";
var reg = /(\d+)年(\d+)月(\d+)日/; 
//END////////////////////
```
